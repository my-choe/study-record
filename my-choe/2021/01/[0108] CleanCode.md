## 📚 Clean Code(클린코드) 독서
## 🔮 1장 깨끗한 코드
**~코드가 존재하리라~**<br/>

**~나쁜 코드~**<br/>

**~나쁜 코드로 치르는 대가~**<br/>
~__ 원대한 재설계의 꿈~<br/>
~__ 태도~<br/>
~__ 원초적 난제~<br/>
~__ 깨끗한 코드라는 예술?~<br/>
~__ 깨끗한 코드란?~<br/>

**~우리들 생각~**<br/>

**~우리는 저자다~**<br/>

**~보이스카우트 규칙~**<br/>

**~프리퀄과 원칙~**<br/>

**~결론~**<br/>

**~참고 문헌~**<br/><br/>

## 🔮 2장 의미 있는 이름
**~들어가면서~**<br/>

**~의도를 분명히 밝혀라~**<br/>

**~그릇된 정보를 피하라~**<br/>

**~의미 있게 구분하라~**<br/>

**~발음하기 쉬운 이름을 사용하라~**<br/>

**~검색하기 쉬운 이름을 사용하라~**<br/>

**~인코딩을 피하라~**<br/>
~__ 헝가리식 표기법~<br/>
~__ 멤버 변수 접두어~<br/>
~__ 인터페이스 클래스와 구현 클래스~<br/>

**~자신의 기억력을 자랑하지 마라~**<br/>

**~클래스 이름~**<br/>

**~메서드 이름~**<br/>

**~기발한 이름은 피하라~**<br/>

**~한 개념에 한 단어를 사용하라~**<br/>

**~말장난을 하지 마라~**<br/>

**~해법 영역에서 가져온 이름을 사용하라~**<br/>

**~문제 영역에서 가져온 이름을 사용하라~**<br/>

**~의미 있는 맥락을 추가하라~**<br/>

**~불필요한 맥락을 없애라~**<br/>

**~마치면서~**<br/><br/>

## 🔮 3장 함수
**작게 만들어라!**<br/>
__ 블록과 들여쓰기<br/>
**한 가지만 해라!**<br/>
__ 함수 내 섹션<br/>
**함수 당 추상화 수준은 하나로!**<br/>
__ 위에서 아래로 코드 읽기: 내려가기 규칙
**Switch 문**<br/>
**서술적인 이름을 사용하라!**<br/>
**함수 인수**<br/>
__ 많이 쓰는 단항 형식<br/>
__ 플래그 인수<br/>
__ 이항 함수<br/>
__ 삼항 함수<br/>
__ 인수 객체<br/>
__ 인수 목록<br/>
__ 동사와 키워드<br/>
**부수 효과를 일으키지 마라!**<br/>
__ 출력 인수<br/>
**명령과 조회를 분리하라!**<br/>
**오류 코드보다 예외를 사용하라!**<br/>
__ Try/Catch 블록 뽑아내기<br/>
__ 오류 처리도 한 가지 작업이다.<br/>
__ Error.java 의존성 자석<br/>

**반복하지 마라!**<br/>
**구조적 프로그래밍**<br/>
**함수를 어떻게 짜죠?**<br/>
**결론**<br/>
**참고 문헌**<br/><br/>

## 🔮 4장 주석
**주석은 나쁜 코드를 보완하지 못한다**<br/>
**코드로 의도를 표현하라!**<br/>
**좋은 주석**<br/>
__ 법적인 주석<br/>
__ 정보를 제공하는 주석<br/>
__ 의도를 설명하는 주석<br/>
__ 의미를 명료하게 밝히는 주석<br/>
__ 결과를 경고하는 주석<br/>
__ TODO 주석<br/>
__ 중요성을 강조하는 주석<br/>
__ 공개 API에서 Javadocs<br/>

**나쁜 주석**<br/>
__ 주절거리는 주석<br/>
__ 같은 이야기를 중복하는 주석<br/>
__ 오해할 여지가 있는 주석<br/>
__ 의무적으로 다는 주석<br/>
__ 이력을 기록하는 주석<br/>
__ 있으나 마나 한 주석<br/>
__ 무서운 잡음<br/>
__ 함수나 변수로 표현할 수 있다면 주석을 달지 마라<br/>
__ 위치를 표시하는 주석<br/>
__ 닫는 괄호에 다는 주석<br/>
__ 공로를 돌리거나 저자를 표시하는 주석<br/>
__ 주석으로 처리한 코드<br/>
__ HTML 주석<br/>
__ 전역 정보<br/>
__ 너무 많은 정보<br/>
__ 모호한 관계<br/>
__ 함수 헤더<br/>
__ 비공개 코드에서 Javadocs<br/>
__ 예제<br/>
**참고 문헌**<br/><br/>

## 🔮 5장 형식 맞추기
**형식을 맞추는 목적**<br/>
**적절한 행 길이를 유지하라**<br/>
__ 신문 기사처럼 작성하라<br/>
__ 개념은 빈 행으로 분리하라<br/>
__ 세로 밀집도<br/>
__ 수직 거리<br/>
__ 세로 순서<br/>

**가로 형식 맞추기**<br/>
__ 가로 공백과 밀집도<br/>
__ 가로 정렬<br/>
__ 들여쓰기<br/>

**가짜 범위**<br/>
**팀 규칙**<br/>
**밥 아저씨의 형식 규칙**<br/><br/>

## 🔮 6장 객체와 자료 구조
**자료 추상화**<br/>
**자료/객체 비대칭**<br/>
**디미터 법칙**<br/>
__ 기차 충돌<br/>
__ 잡종 구조<br/>
__ 구조체 감추기<br/>
**자료 전달 객체**<br/>
__ 활성 레코드<br/>
**결론**<br/>
**참고 문헌**<br/>

## 🔮 7장 오류 처리
**오류 코드보다 예외를 사용하라**<br/>
**Try-Catch-Finally 문부터 작성하라**<br/>
**미확인unchecked 예외를 사용하라**<br/>
**예외에 의미를 제공하라**<br/>
**호출자를 고려해 예외 클래스를 정의하라**<br/>
**정상 흐름을 정의하라**<br/>
**null을 반환하지 마라**<br/>
**null을 전달하지 마라**<br/>
**결론**<br/>
**참고문헌**<br/><br/>

## 🔮 8장 경계
**외부 코드 사용하기**<br/>
**경계 살피고 익히기**<br/>
**log4j 익히기**<br/>
**학습 테스트는 공짜 이상이다**<br/>
**아직 존재하지 않는 코드를 사용하기**<br/>
**깨끗한 경계**<br/>
**참고 문헌**<br/><br/>

## 🔮 9장 단위 테스트
**TDD 법칙 세 가지**<br/>
**깨끗한 테스트 코드 유지하기**<br/>
__ 테스트는 유연성, 유지보수성, 재사용성을 제공한다<br/>
**깨끗한 테스트 코드**<br/>
__ 도메인에 특화된 테스트 언어<br/>
__ 이중 표준<br/>
**테스트 당 assert 하나**<br/>
__ 테스트 당 개념 하나<br/>
**F.I.R.S.T.**<br/>
**결론**<br/>
**참고 문헌**<br/><br/>

## 🔮 10장 클래스
**클래스 체계**<br/>
__ 캡슐화<br/>
**클래스는 작아야 한다!**<br/>
__ 단일 책임 원칙<br/>
__ 응집도Cohesion<br/>
__ 응집도를 유지하면 작은 클래스 여럿이 나온다<br/>
**변경하기 쉬운 클래스**<br/>
__ 변경으로부터 격리<br/>
**참고 문헌**<br/><br/>

## 🔮 11장 시스템
**도시를 세운다면?**<br/>
**시스템 제작과 시스템 사용을 분리하라**<br/>
__ Main 분리<br/>
__ 팩토리<br/>
__ 의존성 주입<br/>
**확장**<br/>
__ 횡단(cross-cutting) 관심사<br/>
**자바 프록시**<br/>
**순수 자바 AOP 프레임워크**<br/>
**AspectJ 관점**<br/>
**테스트 주도 시스템 아키텍처 구축**<br/>
**의사 결정을 최적화하라**<br/>
**명백한 가치가 있을 때 표준을 현명하게 사용하라**<br/>
**시스템은 도메인 특화 언어가 필요하다**<br/>
**결론**<br/>
**참고 문헌**<br/><br/>

## 🔮 12장 창발성(創發性)
**창발적 설계로 깔끔한 코드를 구현하자**<br/>
**단순한 설계 규칙 1: 모든 테스트를 실행하라**<br/>
**단순한 설계 규칙 2~4: 리팩터링**<br/>
**중복을 없애라**<br/>
**표현하라**<br/>
**클래스와 메서드 수를 최소로 줄여라**<br/>
**결론**<br/>
**참고 문헌**<br/><br/>

## 🔮 13장 동시성
**동시성이 필요한 이유?**<br/>
__ 미신과 오해<br/>
**난관**<br/>
**동시성 방어 원칙**<br/>
__ 단일 책임 원칙Single Responsibility Principle, SRP<br/>
__ 따름 정리corollary: 자료 범위를 제한하라<br/>
__ 따름 정리: 자료 사본을 사용하라<br/>
__ 따름 정리: 스레드는 가능한 독립적으로 구현하라<br/>
**라이브러리를 이해하라**<br/>
__ 스레드 환경에 안전한 컬렉션
**실행 모델을 이해하라**<br/>
__ 생산자-소비자Producer-Consumer<br/>
__ 읽기-쓰기Readers-Writers<br/>
__ 식사하는 철학자들Dining Philosophers<br/>
**동기화하는 메서드 사이에 존재하는 의존성을 이해하라**<br/>
**동기화하는 부분을 작게 만들어라**<br/>
**올바른 종료 코드는 구현하기 어렵다**<br/>
**스레드 코드 테스트하기**<br/>
__ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라<br/>
__ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자<br/>
__ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라<br/>
__ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라<br/>
__ 프로세서 수보다 많은 스레드를 돌려보라<br/>
__ 다른 플랫폼에서 돌려보라<br/>
__ 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라<br/>
__ 직접 구현하기<br/>
__ 자동화<br/>
**결론**<br/>
**참고 문헌**<br/><br/>

## 🔮 14장 점진적인 개선
Args 구현
__ 어떻게 짰느냐고?<br/>

Args: 1차 초안
__ 그래서 멈췄다<br/>
__ 점진적으로 개선하다<br/>

String 인수
결론

## 🔮 15장 JUnit 들여다보기
JUnit 프레임워크
결론

## 🔮 16장 SerialDate 리팩터링
첫째, 돌려보자
둘째, 고쳐보자
결론
참고 문헌

## 🔮 17장 냄새와 휴리스틱
주석
__ C1: 부적절한 정보<br/>
__ C2: 쓸모 없는 주석<br/>
__ C3: 중복된 주석<br/>
__ C4: 성의 없는 주석<br/>
__ C5: 주석 처리된 코드<br/>

환경
__ E1: 여러 단계로 빌드해야 한다<br/>
__ E2: 여러 단계로 테스트해야 한다<br/>

함수
__ F1: 너무 많은 인수<br/>
__ F2: 출력 인수<br/>
__ F3: 플래그 인수<br/>
__ F4: 죽은 함수<br/>

일반
__ G1: 한 소스 파일에 여러 언어를 사용한다<br/>
__ G2: 당연한 동작을 구현하지 않는다<br/>
__ G3: 경계를 올바로 처리하지 않는다<br/>
__ G4: 안전 절차 무시<br/>
__ G5: 중복<br/>
__ G6: 추상화 수준이 올바르지 못하다<br/>
__ G7: 기초 클래스가 파생 클래스에 의존한다<br/>
__ G8: 과도한 정보<br/>
__ G9: 죽은 코드<br/>
__ G10: 수직 분리<br/>
__ G11: 일관성 부족<br/>
__ G12: 잡동사니<br/>
__ G13: 인위적 결합<br/>
__ G14: 기능 욕심<br/>
__ G15: 선택자 인수<br/>
__ G16: 모호한 의도<br/>
__ G17: 잘못 지운 책임<br/>
__ G18: 부적절한 static 함수<br/>
__ G19: 서술적 변수<br/>
__ G20: 이름과 기능이 일치하는 함수<br/>
__ G21: 알고리즘을 이해하라<br/>
__ G22: 논리적 의존성은 물리적으로 드러내라<br/>
__ G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라<br/>
__ G24: 표준 표기법을 따르라<br/>
__ G25: 매직 숫자는 명명된 상수로 교체하라<br/>
__ G26: 정확하라<br/>
__ G27: 관례보다 구조를 사용하라<br/>
__ G28: 조건을 캡슐화하라<br/>
__ G29: 부정 조건은 피하라<br/>
__ G30: 함수는 한 가지만 해야 한다<br/>
__ G31: 숨겨진 시간적인 결합<br/>
__ G32: 일관성을 유지하라<br/>
__ G33: 경계 조건을 캡슐화하라<br/>
__ G34: 함수는 추상화 수준을 한 단계만 내려가야 한다<br/>
__ G35: 설정 정보는 최상위 단계에 둬라<br/>
__ G36: 추이적 탐색을 피하라<br/>

자바
__ J1: 긴 import 목록을 피하고 와일드카드를 사용하라<br/>
__ J2: 상수는 상속하지 않는다<br/>
__ J3: 상수 대 Enum<br/>

이름
__ N1: 서술적인 이름을 사용하라<br/>
__ N2: 적절한 추상화 수준에서 이름을 선택하라<br/>
__ N3: 가능하다면 표준 명명법을 사용하라<br/>
__ N4: 명확한 이름<br/>
__ N5: 긴 범위는 긴 이름을 사용하라<br/>
__ N6: 인코딩을 피하라<br/>
__ N7: 이름으로 부수 효과를 설명하라<br/>

테스트
__ T1: 불충분한 테스트<br/>
__ T2: 커버리지 도구를 사용하라!<br/>
__ T3: 사소한 테스트를 건너뛰지 마라<br/>
__ T4: 무시한 테스트는 모호함을 뜻한다<br/>
__ T5: 경계 조건을 테스트하라<br/>
__ T6: 버그 주변은 철저히 테스트하라<br/>
__ T7: 실패 패턴을 살펴라<br/>
__ T8: 테스트 커버리지 패턴을 살펴라<br/>
__ T9: 테스트는 빨라야 한다<br/>

결론
참고 문헌

부록A 동시성 II

클라이언트/서버 예제
__ 서버<br/>
__ 스레드 추가하기<br/>
__ 서버 살펴보기<br/>
__ 결론<br/>

가능한 실행 경로
__ 경로 수<br/>
__ 가능한 순열 수 계산하기<br/>
__ 심층 분석<br/>
__ 결론<br/>

라이브러리를 이해하라
__ Executor 프레임워크<br/>
__ 스레드를 차단하지 않는non blocking 방법<br/>
__ 다중 스레드 환경에서 안전하지 않은 클래스<br/>

메서드 사이에 존재하는 의존성을 조심하라
__ 실패를 용인한다<br/>
__ 클라이언트-기반 잠금<br/>
__ 서버-기반 잠금<br/>

작업 처리량 높이기
__ 작업 처리량 계산 - 단일스레드 환경<br/>
__ 작업 처리량 계산 - 다중 스레드 환경<br/>

데드락
__ 상호 배제Mutual Exclusion<br/>
__ 잠금 & 대기Lock & Wait<br/>
__ 선점 불가No Preemption<br/>
__ 순환 대기Circular Wait<br/>
__ 상호 배제 조건 깨기<br/>
__ 잠금 & 대기 조건 깨기<br/>
__ 선점 불가 조건 깨기<br/>
__ 순환 대기 조건 깨기<br/>
__ 다중 스레드 코드 테스트<br/>
__ 스레드 코드 테스트를 도와주는 도구<br/>

결론

## 🔮 자습서: 전체 코드 예제
__ 클라이언트/서버 - 단일스레드 버전<br/>
__ 클라이언트/서버 - 다중 스레드 버전<br/>

## 🔮 부록B org.jfree.date.SerialDate

## 🔮 부록C 휴리스틱의 교차 참조 목록

### 에필로그
### 용어 대역표
### 약어 목록
### 찾아보기
